package com.github.thed2lab.analysis;

import static com.github.thed2lab.analysis.Constants.AOI_LABEL;
import static com.github.thed2lab.analysis.Constants.FIXATION_DURATION;
import static com.github.thed2lab.analysis.Constants.FIXATION_ID;
import static com.github.thed2lab.analysis.Constants.SCREEN_HEIGHT;
import static com.github.thed2lab.analysis.Constants.SCREEN_WIDTH;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class AreaOfInterests {

    private static final String[] additionalHeaders = {"aoi", "proportion_of_fixations_spent_in_aoi","proportion_of_fixations_durations_spent_in_aoi"};
    private static final String[] perAoiHeaders = {"aoi_pair", "transition_count", "proportion_including_self_transitions", "proportion_excluding_self_transitions"};
    
    public static void generateAOIs(DataEntry allGazeData, DataEntry fixationData, String outputDirectory, String fileName) {
        Map<String, DataEntry> aoiGazeMap = splitAoiData(allGazeData);

        if (aoiGazeMap.size() <= 1) {
            System.out.println("File has no AOIs, no file will be output.");
            return;
        }

        DataEntry filteredFixations = DataFilter.filterByValidity(fixationData, SCREEN_WIDTH, SCREEN_HEIGHT);
        Map<String, DataEntry> aoiFixMap = splitAoiData(filteredFixations);

        // For any AOIs not in aoiFixationMetrics, add an empty DataEntry
        for (String key : aoiGazeMap.keySet()) {
            if (!aoiFixMap.containsKey(key)) {
                DataEntry d = new DataEntry(allGazeData.getHeaders());
                aoiFixMap.put(key, d);
            }
        }
        
        for (String aoiKey : aoiGazeMap.keySet()) {
            DataEntry aoiData = aoiGazeMap.get(aoiKey);
            aoiData.writeToCSV(outputDirectory + "/AOIs", aoiKey + "_all_gaze");
        }

        List<List<String>> aoiMetrics = getMetrics(allGazeData, filteredFixations, aoiGazeMap, aoiFixMap);
        List<List<String>> pairResults = generatePairResults(filteredFixations, aoiGazeMap);

        FileHandler.writeToCSV(aoiMetrics, outputDirectory, fileName + "_AOI_DGMs");
        FileHandler.writeToCSV(pairResults, outputDirectory, fileName+"_AOI_Transitions");
    }

    static Map<String, DataEntry> splitAoiData(DataEntry allData) {
        LinkedHashMap<String, DataEntry> aoiDataMap = new LinkedHashMap<>();
        for (int i = 0; i < allData.rowCount(); i++) {
            String aoi = allData.getValue(AOI_LABEL, i);
            String aoiKey = aoi.equals("") ? "Undefined Area" : aoi;
            if (!aoiDataMap.containsKey(aoiKey)) {
                DataEntry d = new DataEntry(allData.getHeaders());
                aoiDataMap.put(aoiKey, d);
            }
            aoiDataMap.get(aoiKey).process(allData.getRow(i));
        }
        return aoiDataMap;
    }

    static List<List<String>> getMetrics(DataEntry allGaze, DataEntry allFixationData, Map<String, DataEntry> aoiGazeMap, Map<String, DataEntry> aoiFixMap) {
        ArrayList<List<String>> aoiMetrics = new ArrayList<>();
        aoiMetrics.add(new ArrayList<String>());
        
        double totalDuration = getDuration(allFixationData);
        boolean isFirst = true;
        Set<String> aoiKeySet = aoiGazeMap.keySet();
        
        int row = 1;
        for (String aoiKey : aoiKeySet) {
            DataEntry aoi = aoiGazeMap.get(aoiKey);
            DataEntry aoiFixations = aoiFixMap.get(aoiKey);

            List<List<String>> results = Analysis.generateResults(allGaze, aoi, aoiFixations);
            if (isFirst) { //
                isFirst = false;
                List<String> headers = results.get(0);
                aoiMetrics.get(0).addAll(headers); //Adds all headers generated by an analysis, but only for the first AOI
                aoiMetrics.get(0).addAll(Arrays.asList(additionalHeaders));
            }
            results.get(1).add(aoiKey);
            aoiMetrics.add(results.get(1));
            aoiMetrics.get(row).addAll(getProportions(allFixationData, aoiFixations, totalDuration));
            row++;
        }
        return aoiMetrics;
    }

    static List<String> getProportions(DataEntry fixations, DataEntry aoiFixations, double totalDuration) {
        ArrayList<String> results = new ArrayList<>();
        double fixationProportion = (double)aoiFixations.rowCount()/fixations.rowCount(); //Number of fixations in AOI divided by total fixations
        results.add(String.valueOf(fixationProportion));
        double durationIn = getDuration(aoiFixations);
        double durationProportion = durationIn/totalDuration;
        results.add(String.valueOf(durationProportion));
        return results;
    }

    static double getDuration(DataEntry fixations) {
        double durationSum = 0.0;
        for (int i = 0; i < fixations.rowCount(); i++) {
            durationSum += Double.valueOf(fixations.getValue(FIXATION_DURATION, i));
        }

        return durationSum;
    }

    static List<List<String>> generatePairResults(DataEntry fixations, Map<String,DataEntry> aoiGazeMap) {
        LinkedHashMap<String, ArrayList<Integer>> totalTransitions = new LinkedHashMap<>(); // ArrayList<Integer>(Transitions, Inclusive, Exclusive);
        LinkedHashMap<String,LinkedHashMap<String, Integer>> transitionCounts = new LinkedHashMap<>();
        for (int i = 0; i < fixations.rowCount()-1; i++) {
            String curAoi = fixations.getValue(AOI_LABEL, i);
            curAoi = curAoi.equals("") ? "Undefined Area" : curAoi;
            int curId = Integer.valueOf(fixations.getValue(FIXATION_ID, i));
            String nextAoi = fixations.getValue(AOI_LABEL, i+1);
            nextAoi = nextAoi.equals("") ? "Undefined Area" : nextAoi;
            int nextId = Integer.valueOf(fixations.getValue(FIXATION_ID, i+1));
            boolean isValidAOI = (aoiGazeMap.containsKey(curAoi) && aoiGazeMap.containsKey(nextAoi));
            if (isValidAOI && nextId == curId + 1) { //Check if fixations are subsequent
                if (!totalTransitions.containsKey(curAoi)) { //Ensure AOI is initialized in map.
                    ArrayList<Integer> counts = new ArrayList<Integer>();
                    counts.add(0);
                    counts.add(0);
                    totalTransitions.put(curAoi, counts);

                    transitionCounts.put(curAoi, new LinkedHashMap<String, Integer>());
                }
                if (!transitionCounts.get(curAoi).containsKey(nextAoi)) { //Ensure pair is initialized
                    transitionCounts.get(curAoi).put(nextAoi,0);
                }
                ArrayList<Integer> transition = totalTransitions.get(curAoi);
                transition.set(0, transition.get(0)+ 1); //Inclusive counter
                LinkedHashMap<String,Integer>aoiTransitions = transitionCounts.get(curAoi); //Data for current AOI's transitions
                aoiTransitions.put(nextAoi,aoiTransitions.get(nextAoi)+1); //Increment count of curAoi->nextAoi
                if (!curAoi.equals(nextAoi)) {
                    transition.set(1, transition.get(1)+ 1); //Exclusive counter
                }
            }
        }

        ArrayList<List<String>> results = new ArrayList<>();
        results.add(new ArrayList<String>());
        results.get(0).addAll(Arrays.asList(perAoiHeaders));

        int i = 1; // Incremented starts at since element 0 is the list of headers.
        for (String key : totalTransitions.keySet()) {
            int transitionsInclusive = totalTransitions.get(key).get(0);
            int transitionsExclusive = totalTransitions.get(key).get(1);
            for (String otherKey : totalTransitions.keySet()) {
                int transitions = 0;
                if(transitionCounts.get(key).containsKey(otherKey)) {
                    transitions = transitionCounts.get(key).get(otherKey);
                }
                 //Number of transitions from other AOI to current AOI
                results.add(new ArrayList<>());
                results.get(i).add(key + " -> " + otherKey);
                results.get(i).add(String.valueOf(transitions));
                results.get(i).add(String.valueOf((double)transitions/(double)transitionsInclusive));
                if (key != otherKey) results.get(i).add(String.valueOf((double)transitions/(double)transitionsExclusive)); //Only count exclusive transitions for transitions that arent from the AOI to itself (transitions exclusive from A->A is set to be 0)
                else results.get(i).add(String.valueOf(0.0));
                i++;
            }
        }
        return results;
    }
}
